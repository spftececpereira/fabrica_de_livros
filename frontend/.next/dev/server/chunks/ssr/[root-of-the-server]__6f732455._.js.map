{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///home/ecpereira/Documentos/fabrica_de_livros/frontend/components/theme-provider.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport {\n  ThemeProvider as NextThemesProvider,\n  type ThemeProviderProps,\n} from 'next-themes'\n\nexport function ThemeProvider({ children, ...props }: ThemeProviderProps) {\n  return <NextThemesProvider {...props}>{children}</NextThemesProvider>\n}\n"],"names":[],"mappings":";;;;;AAGA;AAHA;;;AAQO,SAAS,cAAc,EAAE,QAAQ,EAAE,GAAG,OAA2B;IACtE,qBAAO,+YAAC,ySAAkB;QAAE,GAAG,KAAK;kBAAG;;;;;;AACzC"}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///home/ecpereira/Documentos/fabrica_de_livros/frontend/lib/query-client.ts"],"sourcesContent":["'use client'\n\nimport { QueryClient } from '@tanstack/react-query'\nimport { toast } from 'sonner'\n\n// Default stale time: 5 minutes\nconst DEFAULT_STALE_TIME = 1000 * 60 * 5\n\n// Default cache time: 10 minutes  \nconst DEFAULT_CACHE_TIME = 1000 * 60 * 10\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: DEFAULT_STALE_TIME,\n      gcTime: DEFAULT_CACHE_TIME,\n      retry: (failureCount, error: any) => {\n        // Don't retry on 4xx errors (client errors)\n        if (error?.status >= 400 && error?.status < 500) {\n          return false\n        }\n        // Retry up to 3 times for other errors\n        return failureCount < 3\n      },\n      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n      refetchOnWindowFocus: false,\n      refetchOnMount: true,\n      refetchOnReconnect: 'always',\n    },\n    mutations: {\n      retry: (failureCount, error: any) => {\n        // Don't retry mutations on client errors\n        if (error?.status >= 400 && error?.status < 500) {\n          return false\n        }\n        // Retry once for server errors\n        return failureCount < 1\n      },\n      onError: (error: any) => {\n        // Global error handling for mutations\n        const message = error?.message || error?.detail || 'Algo deu errado. Tente novamente.'\n        toast.error(message)\n      },\n    },\n  },\n})\n\n// Query Keys Factory\nexport const queryKeys = {\n  // Auth\n  auth: {\n    me: ['auth', 'me'] as const,\n    refresh: ['auth', 'refresh'] as const,\n  },\n  \n  // Books\n  books: {\n    all: ['books'] as const,\n    lists: () => [...queryKeys.books.all, 'list'] as const,\n    list: (filters?: Record<string, unknown>) => \n      [...queryKeys.books.lists(), { ...filters }] as const,\n    details: () => [...queryKeys.books.all, 'detail'] as const,\n    detail: (id: number) => [...queryKeys.books.details(), id] as const,\n    stats: () => [...queryKeys.books.all, 'stats'] as const,\n    recent: () => [...queryKeys.books.all, 'recent'] as const,\n    search: (term: string) => [...queryKeys.books.all, 'search', term] as const,\n    generation: {\n      status: (taskId: string) => ['books', 'generation', 'status', taskId] as const,\n    },\n  },\n\n  // Users\n  users: {\n    all: ['users'] as const,\n    lists: () => [...queryKeys.users.all, 'list'] as const,\n    list: (filters?: Record<string, unknown>) => \n      [...queryKeys.users.lists(), { ...filters }] as const,\n    details: () => [...queryKeys.users.all, 'detail'] as const,\n    detail: (id: number) => [...queryKeys.users.details(), id] as const,\n  },\n\n  // Badges\n  badges: {\n    all: ['badges'] as const,\n    user: (userId: number) => [...queryKeys.badges.all, 'user', userId] as const,\n    available: () => [...queryKeys.badges.all, 'available'] as const,\n  },\n\n  // Health\n  health: {\n    status: ['health', 'status'] as const,\n  },\n} as const\n\n// Invalidation helpers\nexport const invalidateQueries = {\n  auth: () => queryClient.invalidateQueries({ queryKey: queryKeys.auth.me }),\n  \n  books: {\n    all: () => queryClient.invalidateQueries({ queryKey: queryKeys.books.all }),\n    lists: () => queryClient.invalidateQueries({ queryKey: queryKeys.books.lists() }),\n    detail: (id: number) => queryClient.invalidateQueries({ queryKey: queryKeys.books.detail(id) }),\n    stats: () => queryClient.invalidateQueries({ queryKey: queryKeys.books.stats() }),\n  },\n  \n  badges: {\n    all: () => queryClient.invalidateQueries({ queryKey: queryKeys.badges.all }),\n    user: (userId: number) => queryClient.invalidateQueries({ queryKey: queryKeys.badges.user(userId) }),\n  },\n}\n\n// Pre-configured query options\nexport const queryOptions = {\n  // Fast refetch for real-time data\n  realtime: {\n    staleTime: 0,\n    gcTime: 1000 * 60 * 2, // 2 minutes\n    refetchInterval: 5000, // 5 seconds\n  },\n  \n  // Long cache for static data\n  static: {\n    staleTime: 1000 * 60 * 60, // 1 hour\n    gcTime: 1000 * 60 * 60 * 24, // 24 hours\n  },\n  \n  // Background refetch for user data\n  background: {\n    staleTime: DEFAULT_STALE_TIME,\n    gcTime: DEFAULT_CACHE_TIME,\n    refetchInterval: 1000 * 60 * 30, // 30 minutes\n  },\n} as const"],"names":[],"mappings":"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"}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///home/ecpereira/Documentos/fabrica_de_livros/frontend/lib/types/api.ts"],"sourcesContent":["// Generic API Response Types\nexport interface APIResponse<T = unknown> {\n  data?: T\n  message?: string\n  status: number\n}\n\nexport interface APIError {\n  detail: string\n  field?: string\n  error_code?: string\n  details?: Record<string, unknown>\n}\n\nexport interface PaginatedResponse<T> {\n  items: T[]\n  total: number\n  skip: number\n  limit: number\n  has_next: boolean\n  has_previous: boolean\n}\n\n// Request/Response Types\nexport interface AuthResponse {\n  access_token: string\n  token_type: string\n  expires_in: number\n  user: import('./user').User\n}\n\nexport interface RefreshTokenResponse {\n  access_token: string\n  token_type: string\n  expires_in: number\n}\n\n// Query Parameters\nexport interface BookFilters {\n  status_filter?: string\n  style_filter?: string\n  search?: string\n  skip?: number\n  limit?: number\n  sort_by?: 'created_at' | 'title' | 'updated_at'\n  sort_order?: 'asc' | 'desc'\n}\n\nexport interface UserFilters {\n  role_filter?: string\n  status_filter?: string\n  search?: string\n  skip?: number\n  limit?: number\n}\n\n// WebSocket Message Types\nexport interface WebSocketMessage {\n  type: string\n  data: unknown\n  timestamp: string\n}\n\nexport interface BookGenerationMessage extends WebSocketMessage {\n  type: 'book_generation_update'\n  data: {\n    book_id: number\n    task_id: string\n    status: string\n    progress: number\n    message: string\n    current_step?: string\n  }\n}\n\nexport interface NotificationMessage extends WebSocketMessage {\n  type: 'notification'\n  data: {\n    id: string\n    title: string\n    message: string\n    type: 'info' | 'success' | 'warning' | 'error'\n    action_url?: string\n  }\n}\n\n// File Upload Types\nexport interface FileUploadResponse {\n  url: string\n  filename: string\n  size: number\n  content_type: string\n}\n\n// Badge/Achievement Types\nexport interface Badge {\n  id: number\n  code: string\n  name: string\n  description: string | null\n  icon: string | null\n  category: BadgeCategory\n  created_at: string\n}\n\nexport interface UserBadge {\n  id: number\n  user_id: number\n  badge_id: number\n  earned_at: string\n  badge: Badge\n}\n\nexport enum BadgeCategory {\n  CREATION = \"creation\",\n  MILESTONE = \"milestone\", \n  STYLE = \"style\",\n  SPECIAL = \"special\",\n}\n\n// Health Check Types\nexport interface HealthCheck {\n  status: 'healthy' | 'unhealthy'\n  version: string\n  timestamp: string\n  checks: {\n    database: 'ok' | 'error'\n    redis: 'ok' | 'error'\n    ai_service: 'ok' | 'error'\n  }\n}\n\n// Error Handling\nexport class APIErrorClass extends Error {\n  public status: number\n  public field?: string\n  public error_code?: string\n  public details?: Record<string, unknown>\n\n  constructor(\n    message: string,\n    status: number = 500,\n    field?: string,\n    error_code?: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message)\n    this.name = 'APIError'\n    this.status = status\n    this.field = field\n    this.error_code = error_code\n    this.details = details\n  }\n}\n\n// Type Guards\nexport function isAPIError(error: unknown): error is APIError {\n  return typeof error === 'object' && error !== null && 'detail' in error\n}\n\nexport function isAuthResponse(data: unknown): data is AuthResponse {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'access_token' in data &&\n    'user' in data\n  )\n}"],"names":[],"mappings":"AAAA,6BAA6B;;;;;;;;;;;AAiHtB,IAAA,AAAK,uCAAA;;;;;WAAA;;AAoBL,MAAM,sBAAsB;IAC1B,OAAc;IACd,MAAc;IACd,WAAmB;IACnB,QAAiC;IAExC,YACE,OAAe,EACf,SAAiB,GAAG,EACpB,KAAc,EACd,UAAmB,EACnB,OAAiC,CACjC;QACA,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,OAAO,GAAG;IACjB;AACF;AAGO,SAAS,WAAW,KAAc;IACvC,OAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,YAAY;AACpE;AAEO,SAAS,eAAe,IAAa;IAC1C,OACE,OAAO,SAAS,YAChB,SAAS,QACT,kBAAkB,QAClB,UAAU;AAEd"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":["file:///home/ecpereira/Documentos/fabrica_de_livros/frontend/lib/api.ts"],"sourcesContent":["'use client'\n\nimport { toast } from 'sonner'\nimport { APIErrorClass, isAPIError } from './types/api'\n\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'\n\ninterface FetchOptions extends RequestInit {\n  token?: string\n  skipAuth?: boolean\n  skipErrorToast?: boolean\n}\n\ninterface APIClient {\n  get: <T = unknown>(endpoint: string, options?: FetchOptions) => Promise<T>\n  post: <T = unknown>(endpoint: string, data?: unknown, options?: FetchOptions) => Promise<T>\n  put: <T = unknown>(endpoint: string, data?: unknown, options?: FetchOptions) => Promise<T>\n  delete: <T = unknown>(endpoint: string, options?: FetchOptions) => Promise<T>\n  patch: <T = unknown>(endpoint: string, data?: unknown, options?: FetchOptions) => Promise<T>\n}\n\n// Token management\nlet currentToken: string | null = null\nlet tokenRefreshPromise: Promise<string> | null = null\n\nconst getStoredToken = (): string | null => {\n  if (typeof window === 'undefined') return null\n  return localStorage.getItem('access_token')\n}\n\nconst setStoredToken = (token: string | null): void => {\n  if (typeof window === 'undefined') return\n  if (token) {\n    localStorage.setItem('access_token', token)\n  } else {\n    localStorage.removeItem('access_token')\n  }\n  currentToken = token\n}\n\nconst refreshToken = async (): Promise<string> => {\n  if (tokenRefreshPromise) {\n    return tokenRefreshPromise\n  }\n\n  tokenRefreshPromise = (async () => {\n    try {\n      const response = await fetch(`${API_URL}/api/v1/auth/refresh`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${currentToken || getStoredToken()}`,\n        },\n      })\n\n      if (!response.ok) {\n        throw new Error('Token refresh failed')\n      }\n\n      const data = await response.json()\n      const newToken = data.access_token\n\n      setStoredToken(newToken)\n      return newToken\n    } catch (error) {\n      // Token refresh failed, clear stored token and redirect to login\n      setStoredToken(null)\n      if (typeof window !== 'undefined') {\n        if (typeof window !== 'undefined') {\n          window.location.href = '/login'\n        }\n      }\n      throw error\n    } finally {\n      tokenRefreshPromise = null\n    }\n  })()\n\n  return tokenRefreshPromise\n}\n\n// Core fetch function with automatic token handling\nexport async function fetchAPI<T = unknown>(\n  endpoint: string, \n  options: FetchOptions = {}\n): Promise<T> {\n  const { \n    token, \n    skipAuth = false, \n    skipErrorToast = false,\n    headers, \n    ...rest \n  } = options\n\n  // Get token from parameter, current token, or storage\n  let authToken = token || currentToken || (skipAuth ? null : getStoredToken())\n\n  const defaultHeaders: Record<string, string> = {\n    'Content-Type': 'application/json',\n    ...(authToken && !skipAuth ? { Authorization: `Bearer ${authToken}` } : {}),\n    ...(headers as Record<string, string>),\n  }\n\n  let response: Response\n\n  try {\n    response = await fetch(`${API_URL}${endpoint}`, {\n      headers: defaultHeaders,\n      ...rest,\n    })\n  } catch (error) {\n    const message = 'Erro de conectividade. Verifique sua conexão com a internet.'\n    if (!skipErrorToast) {\n      toast.error(message)\n    }\n    throw new APIErrorClass(message, 0)\n  }\n\n  // Handle 401 - try token refresh if we have a token\n  if (response.status === 401 && authToken && !skipAuth) {\n    try {\n      const newToken = await refreshToken()\n      \n      // Retry the request with new token\n      const retryHeaders = {\n        ...defaultHeaders,\n        Authorization: `Bearer ${newToken}`,\n      }\n\n      response = await fetch(`${API_URL}${endpoint}`, {\n        headers: retryHeaders,\n        ...rest,\n      })\n    } catch (refreshError) {\n      // Refresh failed, let the original 401 be handled below\n    }\n  }\n\n  // Handle error responses\n  if (!response.ok) {\n    let errorData: any = {}\n    \n    try {\n      errorData = await response.json()\n    } catch {\n      errorData = { detail: 'Erro desconhecido do servidor' }\n    }\n\n    const apiError = new APIErrorClass(\n      errorData.detail || `Erro ${response.status}`,\n      response.status,\n      errorData.field,\n      errorData.error_code,\n      errorData.details\n    )\n\n    // Show error toast unless explicitly disabled\n    if (!skipErrorToast) {\n      const errorMessage = apiError.message || 'Algo deu errado. Tente novamente.'\n      \n      if (response.status >= 500) {\n        toast.error('Erro interno do servidor. Nossa equipe foi notificada.')\n      } else if (response.status === 429) {\n        toast.error('Muitas tentativas. Aguarde um momento antes de tentar novamente.')\n      } else {\n        toast.error(errorMessage)\n      }\n    }\n\n    throw apiError\n  }\n\n  // Handle empty responses (e.g. 204 No Content)\n  if (response.status === 204 || response.headers.get('content-length') === '0') {\n    return null as T\n  }\n\n  try {\n    return await response.json()\n  } catch (error) {\n    throw new APIErrorClass('Resposta inválida do servidor', 502)\n  }\n}\n\n// API client with convenient methods\nexport const api: APIClient = {\n  get: <T = unknown>(endpoint: string, options?: FetchOptions) =>\n    fetchAPI<T>(endpoint, { ...options, method: 'GET' }),\n\n  post: <T = unknown>(endpoint: string, data?: unknown, options?: FetchOptions) =>\n    fetchAPI<T>(endpoint, {\n      ...options,\n      method: 'POST',\n      body: data ? JSON.stringify(data) : undefined,\n    }),\n\n  put: <T = unknown>(endpoint: string, data?: unknown, options?: FetchOptions) =>\n    fetchAPI<T>(endpoint, {\n      ...options,\n      method: 'PUT',\n      body: data ? JSON.stringify(data) : undefined,\n    }),\n\n  delete: <T = unknown>(endpoint: string, options?: FetchOptions) =>\n    fetchAPI<T>(endpoint, { ...options, method: 'DELETE' }),\n\n  patch: <T = unknown>(endpoint: string, data?: unknown, options?: FetchOptions) =>\n    fetchAPI<T>(endpoint, {\n      ...options,\n      method: 'PATCH',\n      body: data ? JSON.stringify(data) : undefined,\n    }),\n}\n\n// File upload helper\nexport const uploadFile = async (\n  endpoint: string,\n  file: File,\n  options?: FetchOptions\n): Promise<any> => {\n  const { token, headers, ...rest } = options || {}\n  \n  const authToken = token || currentToken || getStoredToken()\n  const formData = new FormData()\n  formData.append('file', file)\n\n  const uploadHeaders: Record<string, string> = {\n    ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),\n    ...(headers as Record<string, string>),\n  }\n\n  // Don't set Content-Type for FormData, let browser handle it\n  delete uploadHeaders['Content-Type']\n\n  const response = await fetch(`${API_URL}${endpoint}`, {\n    method: 'POST',\n    headers: uploadHeaders,\n    body: formData,\n    ...rest,\n  })\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}))\n    throw new APIErrorClass(\n      errorData.detail || 'Upload failed',\n      response.status,\n      errorData.field,\n      errorData.error_code,\n      errorData.details\n    )\n  }\n\n  return response.json()\n}\n\n// Download helper\nexport const downloadFile = async (\n  endpoint: string,\n  filename?: string,\n  options?: FetchOptions\n): Promise<void> => {\n  const { token, ...rest } = options || {}\n  const authToken = token || currentToken || getStoredToken()\n\n  const response = await fetch(`${API_URL}${endpoint}`, {\n    headers: {\n      ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),\n    },\n    ...rest,\n  })\n\n  if (!response.ok) {\n    throw new APIErrorClass('Download failed', response.status)\n  }\n\n  const blob = await response.blob()\n  \n  if (typeof window !== 'undefined') {\n    const url = window.URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = filename || 'download'\n    document.body.appendChild(a)\n    a.click()\n    window.URL.revokeObjectURL(url)\n    document.body.removeChild(a)\n  }\n}\n\n// Utility functions\nexport const setAuthToken = (token: string | null): void => {\n  setStoredToken(token)\n}\n\nexport const getAuthToken = (): string | null => {\n  return currentToken || getStoredToken()\n}\n\nexport const clearAuthToken = (): void => {\n  setStoredToken(null)\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 506, "column": 0}, "map": {"version":3,"sources":["file:///home/ecpereira/Documentos/fabrica_de_livros/frontend/lib/stores/auth-store.ts"],"sourcesContent":["'use client'\n\nimport { create } from 'zustand'\nimport { persist, createJSONStorage } from 'zustand/middleware'\nimport { User } from '../types/user'\n\ninterface AuthState {\n  user: User | null\n  isAuthenticated: boolean\n  isLoading: boolean\n  \n  // Actions\n  setUser: (user: User | null) => void\n  setLoading: (loading: boolean) => void\n  logout: () => void\n  updateUser: (updates: Partial<User>) => void\n}\n\nexport const useAuthStore = create<AuthState>()(\n  persist(\n    (set, get) => ({\n      user: null,\n      isAuthenticated: false,\n      isLoading: true,\n\n      setUser: (user: User | null) => {\n        set({ \n          user, \n          isAuthenticated: !!user,\n          isLoading: false \n        })\n      },\n\n      setLoading: (loading: boolean) => {\n        set({ isLoading: loading })\n      },\n\n      logout: () => {\n        set({ \n          user: null, \n          isAuthenticated: false, \n          isLoading: false \n        })\n        \n        // Clear tokens\n        if (typeof window !== 'undefined') {\n          localStorage.removeItem('access_token')\n        }\n      },\n\n      updateUser: (updates: Partial<User>) => {\n        const currentUser = get().user\n        if (currentUser) {\n          set({ \n            user: { ...currentUser, ...updates } \n          })\n        }\n      },\n    }),\n    {\n      name: 'auth-storage',\n      storage: createJSONStorage(() => localStorage),\n      partialize: (state) => ({ \n        user: state.user,\n        isAuthenticated: state.isAuthenticated,\n      }),\n      onRehydrateStorage: () => (state) => {\n        // Reset loading state after hydration\n        if (state) {\n          state.isLoading = false\n        }\n      },\n    }\n  )\n)"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;AAkBO,MAAM,eAAe,IAAA,sUAAM,IAChC,IAAA,4UAAO,EACL,CAAC,KAAK,MAAQ,CAAC;QACb,MAAM;QACN,iBAAiB;QACjB,WAAW;QAEX,SAAS,CAAC;YACR,IAAI;gBACF;gBACA,iBAAiB,CAAC,CAAC;gBACnB,WAAW;YACb;QACF;QAEA,YAAY,CAAC;YACX,IAAI;gBAAE,WAAW;YAAQ;QAC3B;QAEA,QAAQ;YACN,IAAI;gBACF,MAAM;gBACN,iBAAiB;gBACjB,WAAW;YACb;YAEA,eAAe;YACf;;QAGF;QAEA,YAAY,CAAC;YACX,MAAM,cAAc,MAAM,IAAI;YAC9B,IAAI,aAAa;gBACf,IAAI;oBACF,MAAM;wBAAE,GAAG,WAAW;wBAAE,GAAG,OAAO;oBAAC;gBACrC;YACF;QACF;IACF,CAAC,GACD;IACE,MAAM;IACN,SAAS,IAAA,sVAAiB,EAAC,IAAM;IACjC,YAAY,CAAC,QAAU,CAAC;YACtB,MAAM,MAAM,IAAI;YAChB,iBAAiB,MAAM,eAAe;QACxC,CAAC;IACD,oBAAoB,IAAM,CAAC;YACzB,sCAAsC;YACtC,IAAI,OAAO;gBACT,MAAM,SAAS,GAAG;YACpB;QACF;AACF"}},
    {"offset": {"line": 570, "column": 0}, "map": {"version":3,"sources":["file:///home/ecpereira/Documentos/fabrica_de_livros/frontend/lib/queries/auth-queries.ts"],"sourcesContent":["'use client'\n\nimport { useMutation, useQuery } from '@tanstack/react-query'\nimport { toast } from 'sonner'\nimport { api, setAuthToken, clearAuthToken } from '../api'\nimport { queryKeys, invalidateQueries } from '../query-client'\nimport { useAuthStore } from '../stores/auth-store'\nimport { \n  LoginRequest, \n  TokenResponse, \n  User, \n  UserCreate, \n  UserUpdate,\n  ChangePasswordRequest \n} from '../types/user'\n\n// Login mutation\nexport const useLogin = () => {\n  const setUser = useAuthStore(state => state.setUser)\n  \n  return useMutation({\n    mutationFn: async (credentials: LoginRequest): Promise<TokenResponse> => {\n      const formData = new FormData()\n      formData.append('username', credentials.username)\n      formData.append('password', credentials.password)\n\n      return api.post<TokenResponse>('/api/v1/auth/login', formData, {\n        headers: {\n          // Let the browser set Content-Type for FormData\n          'Content-Type': undefined as any,\n        },\n      })\n    },\n    onSuccess: (data) => {\n      setAuthToken(data.access_token)\n      setUser(data.user)\n      toast.success('Login realizado com sucesso!')\n    },\n    onError: (error: any) => {\n      toast.error(error.message || 'Erro ao fazer login')\n    },\n  })\n}\n\n// Register mutation\nexport const useRegister = () => {\n  const setUser = useAuthStore(state => state.setUser)\n  \n  return useMutation({\n    mutationFn: async (userData: UserCreate): Promise<TokenResponse> => {\n      return api.post<TokenResponse>('/api/v1/auth/register', userData)\n    },\n    onSuccess: (data) => {\n      setAuthToken(data.access_token)\n      setUser(data.user)\n      toast.success('Conta criada com sucesso!')\n    },\n    onError: (error: any) => {\n      toast.error(error.message || 'Erro ao criar conta')\n    },\n  })\n}\n\n// Logout mutation\nexport const useLogout = () => {\n  const logout = useAuthStore(state => state.logout)\n  \n  return useMutation({\n    mutationFn: async () => {\n      // Call backend logout endpoint (optional)\n      try {\n        await api.post('/api/v1/auth/logout', {}, { skipErrorToast: true })\n      } catch {\n        // Ignore errors, we're logging out anyway\n      }\n    },\n    onSuccess: () => {\n      clearAuthToken()\n      logout()\n      toast.success('Logout realizado com sucesso!')\n    },\n    onSettled: () => {\n      // Always clear local state even if backend call fails\n      clearAuthToken()\n      logout()\n    },\n  })\n}\n\n// Get current user query\nexport const useCurrentUser = () => {\n  const { setUser, setLoading, user, isAuthenticated } = useAuthStore()\n  \n  return useQuery({\n    queryKey: queryKeys.auth.me,\n    queryFn: async (): Promise<User> => {\n      return api.get<User>('/api/v1/auth/me')\n    },\n    enabled: isAuthenticated && !!user,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    retry: (failureCount, error: any) => {\n      // Don't retry on 401 (user not authenticated)\n      if (error?.status === 401) {\n        return false\n      }\n      return failureCount < 2\n    },\n    onSuccess: (data) => {\n      setUser(data)\n      setLoading(false)\n    },\n    onError: (error: any) => {\n      if (error?.status === 401) {\n        // Token is invalid, clear auth state\n        clearAuthToken()\n        setUser(null)\n      }\n      setLoading(false)\n    },\n  })\n}\n\n// Refresh token mutation\nexport const useRefreshToken = () => {\n  const setUser = useAuthStore(state => state.setUser)\n  \n  return useMutation({\n    mutationFn: async (): Promise<TokenResponse> => {\n      return api.post<TokenResponse>('/api/v1/auth/refresh')\n    },\n    onSuccess: (data) => {\n      setAuthToken(data.access_token)\n      setUser(data.user)\n    },\n    onError: () => {\n      // Refresh failed, clear auth state\n      clearAuthToken()\n      setUser(null)\n    },\n  })\n}\n\n// Update profile mutation\nexport const useUpdateProfile = () => {\n  const updateUser = useAuthStore(state => state.updateUser)\n  \n  return useMutation({\n    mutationFn: async (updates: UserUpdate): Promise<User> => {\n      return api.put<User>('/api/v1/auth/me', updates)\n    },\n    onSuccess: (data) => {\n      updateUser(data)\n      invalidateQueries.auth()\n      toast.success('Perfil atualizado com sucesso!')\n    },\n    onError: (error: any) => {\n      toast.error(error.message || 'Erro ao atualizar perfil')\n    },\n  })\n}\n\n// Change password mutation\nexport const useChangePassword = () => {\n  return useMutation({\n    mutationFn: async (passwords: ChangePasswordRequest): Promise<void> => {\n      return api.post('/api/v1/auth/change-password', passwords)\n    },\n    onSuccess: () => {\n      toast.success('Senha alterada com sucesso!')\n    },\n    onError: (error: any) => {\n      toast.error(error.message || 'Erro ao alterar senha')\n    },\n  })\n}\n\n// Verify email mutation (if implemented in backend)\nexport const useVerifyEmail = () => {\n  return useMutation({\n    mutationFn: async (token: string): Promise<void> => {\n      return api.post('/api/v1/auth/verify-email', { token })\n    },\n    onSuccess: () => {\n      toast.success('Email verificado com sucesso!')\n      invalidateQueries.auth()\n    },\n    onError: (error: any) => {\n      toast.error(error.message || 'Erro ao verificar email')\n    },\n  })\n}\n\n// Request password reset mutation (if implemented in backend)\nexport const useRequestPasswordReset = () => {\n  return useMutation({\n    mutationFn: async (email: string): Promise<void> => {\n      return api.post('/api/v1/auth/request-password-reset', { email })\n    },\n    onSuccess: () => {\n      toast.success('Email de recuperação enviado!')\n    },\n    onError: (error: any) => {\n      toast.error(error.message || 'Erro ao enviar email de recuperação')\n    },\n  })\n}\n\n// Reset password mutation (if implemented in backend)\nexport const useResetPassword = () => {\n  return useMutation({\n    mutationFn: async ({ token, new_password }: { token: string; new_password: string }): Promise<void> => {\n      return api.post('/api/v1/auth/reset-password', { token, new_password })\n    },\n    onSuccess: () => {\n      toast.success('Senha redefinida com sucesso!')\n    },\n    onError: (error: any) => {\n      toast.error(error.message || 'Erro ao redefinir senha')\n    },\n  })\n}\n\n// Custom hook for auth state\nexport const useAuth = () => {\n  const authStore = useAuthStore()\n  const currentUserQuery = useCurrentUser()\n  const loginMutation = useLogin()\n  const registerMutation = useRegister()\n  const logoutMutation = useLogout()\n  \n  return {\n    // State\n    user: authStore.user,\n    isAuthenticated: authStore.isAuthenticated,\n    isLoading: authStore.isLoading || currentUserQuery.isLoading,\n    \n    // Mutations\n    login: loginMutation.mutateAsync,\n    register: registerMutation.mutateAsync,\n    logout: logoutMutation.mutate,\n    \n    // Mutation states\n    isLoggingIn: loginMutation.isPending,\n    isRegistering: registerMutation.isPending,\n    isLoggingOut: logoutMutation.isPending,\n    \n    // Query\n    refetchUser: currentUserQuery.refetch,\n    \n    // Store actions\n    setUser: authStore.setUser,\n    updateUser: authStore.updateUser,\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 824, "column": 0}, "map": {"version":3,"sources":["file:///home/ecpereira/Documentos/fabrica_de_livros/frontend/lib/auth/auth-provider.tsx"],"sourcesContent":["'use client'\n\nimport React, { createContext, useContext, useEffect, ReactNode } from 'react'\nimport { QueryClientProvider } from '@tanstack/react-query'\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools'\nimport { Toaster } from 'sonner'\nimport { queryClient } from '../query-client'\nimport { useAuth } from '../queries/auth-queries'\nimport { useAuthStore } from '../stores/auth-store'\nimport { getAuthToken } from '../api'\n\ninterface AuthContextType {\n  user: any\n  isAuthenticated: boolean\n  isLoading: boolean\n  login: (credentials: any) => Promise<void>\n  register: (userData: any) => Promise<void>\n  logout: () => void\n  refetchUser: () => void\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\ninterface AuthProviderProps {\n  children: ReactNode\n}\n\nfunction AuthProviderInner({ children }: AuthProviderProps) {\n  const auth = useAuth()\n  const { setUser, setLoading } = useAuthStore()\n\n  useEffect(() => {\n    // Check if user is already logged in on mount\n    const token = getAuthToken()\n    \n    if (token && !auth.user) {\n      // Token exists but no user in store, try to fetch user\n      auth.refetchUser()\n    } else if (!token && auth.user) {\n      // No token but user in store, clear user\n      setUser(null)\n    } else {\n      // No token and no user, or both exist - set loading to false\n      setLoading(false)\n    }\n  }, []) // Empty dependency array - only run on mount\n\n  const contextValue: AuthContextType = {\n    user: auth.user,\n    isAuthenticated: auth.isAuthenticated,\n    isLoading: auth.isLoading,\n    login: auth.login,\n    register: auth.register,\n    logout: auth.logout,\n    refetchUser: auth.refetchUser,\n  }\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport function AuthProvider({ children }: AuthProviderProps) {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <AuthProviderInner>\n        {children}\n        <Toaster \n          position=\"top-right\"\n          toastOptions={{\n            duration: 4000,\n            style: {\n              background: 'hsl(var(--background))',\n              color: 'hsl(var(--foreground))',\n              border: '1px solid hsl(var(--border))',\n            },\n          }}\n        />\n      </AuthProviderInner>\n      {process.env.NODE_ENV === 'development' && (\n        <ReactQueryDevtools initialIsOpen={false} />\n      )}\n    </QueryClientProvider>\n  )\n}\n\nexport function useAuthContext() {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error('useAuthContext must be used within an AuthProvider')\n  }\n  return context\n}"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;;;;;;;;;;AAqBA,MAAM,4BAAc,IAAA,uXAAa,EAA8B;AAM/D,SAAS,kBAAkB,EAAE,QAAQ,EAAqB;IACxD,MAAM,OAAO,IAAA,4IAAO;IACpB,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,GAAG,IAAA,8IAAY;IAE5C,IAAA,mXAAS,EAAC;QACR,8CAA8C;QAC9C,MAAM,QAAQ,IAAA,0HAAY;QAE1B,IAAI,SAAS,CAAC,KAAK,IAAI,EAAE;YACvB,uDAAuD;YACvD,KAAK,WAAW;QAClB,OAAO,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE;YAC9B,yCAAyC;YACzC,QAAQ;QACV,OAAO;YACL,6DAA6D;YAC7D,WAAW;QACb;IACF,GAAG,EAAE,GAAE,6CAA6C;IAEpD,MAAM,eAAgC;QACpC,MAAM,KAAK,IAAI;QACf,iBAAiB,KAAK,eAAe;QACrC,WAAW,KAAK,SAAS;QACzB,OAAO,KAAK,KAAK;QACjB,UAAU,KAAK,QAAQ;QACvB,QAAQ,KAAK,MAAM;QACnB,aAAa,KAAK,WAAW;IAC/B;IAEA,qBACE,+YAAC,YAAY,QAAQ;QAAC,OAAO;kBAC1B;;;;;;AAGP;AAEO,SAAS,aAAa,EAAE,QAAQ,EAAqB;IAC1D,qBACE,+YAAC,8SAAmB;QAAC,QAAQ,qIAAW;;0BACtC,+YAAC;;oBACE;kCACD,+YAAC,mRAAO;wBACN,UAAS;wBACT,cAAc;4BACZ,UAAU;4BACV,OAAO;gCACL,YAAY;gCACZ,OAAO;gCACP,QAAQ;4BACV;wBACF;;;;;;;;;;;;YAGH,oDAAyB,+BACxB,+YAAC,gYAAkB;gBAAC,eAAe;;;;;;;;;;;;AAI3C;AAEO,SAAS;IACd,MAAM,UAAU,IAAA,oXAAU,EAAC;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT"}}]
}